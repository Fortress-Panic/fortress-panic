#!/usr/bin/env node
// jshint esversion:8
/**
 * Module dependencies.
 */
var app = require('../app');
var http = require('http');
const configDB = require('../config/properties');
const socketIO = require('socket.io');
const fetch = require('node-fetch');
const playerCardsState = require('../player-cards/player-cards.state');
const playerCardsModel = require('../player-cards/player-cards.dao');
const playerDeckState = require('../player-deck/player-deck.state');
const playerDeckModel = require('../player-deck/player-deck.dao');
const monsterDeckState = require('../monster-deck/monster-deck.states');
const monsterDeckModel = require('../monster-deck/monster-deck.dao');
const MonstersState = require('../monsters/monsters.states');
const monstersModel = require('../monsters/monsters.dao');
const defensesState = require('../defenses/defenses.states');
const defensesModel = require('../defenses/defenses.dao');

/**
 * Get port from environment and store in Express.
 */

var port = process.env.PORT || configDB.PORT;
// app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);
const io = socketIO(server);

let players = {};
let started = [false];

io.on("connection", (socket) => {
  console.log("New client connected at id: " + socket.id);
  players[socket.id] = {
    playerId: socket.id,
    displayName: 'Player ' + socket.id.slice(0,4),
    playerCards: [],
    points: 0,
    logged: false,
    currentTurn: false
  };
  // send the players object to the new player
  socket.emit('currentPlayers', players);

  socket.emit('getDefenses');

  socket.emit('getMonsters');

  socket.emit('hasGameStarted', started[0]);

  socket.broadcast.emit('getCurrentPlayer', socket.id);

  socket.broadcast.emit('getCurrentPhase', socket.id);

  socket.on('returnCurrentPhase', function(obj) {
      io.emit('setCurrentPhase', obj);
  });

  socket.on('returnCurrentPlayer', function(obj) {
    io.emit('updateCurrentPlayer', obj);
  });
  // update all other players of the new player
  socket.broadcast.emit('newPlayer', players[socket.id]);

  socket.on('firstStartButtonPress', function() {
    started[0] = true;
    socket.broadcast.emit('otherPlayerStartedGame', 'THE GAME HAS STARTED.');
    let currentPlayer = main();
    socket.emit('startClientDrawPhase', currentPlayer);
  });

  socket.on('playerLogin', function(id) {
    players[socket.id].logged = true; 
    io.emit('updateLoginName', id);
  });

  socket.on('logOutPlayer', function(id) {
    players[id].displayName = 'Player ' + id.slice(0,4);
    players[socket.id].logged = false;
    socket.broadcast.emit('logOutPlayer', id);
    socket.broadcast.emit('changeName', [id, 'Player ' + id.slice(0,4)]);
  });

  socket.on('sendMessage', function(data){
    io.emit('receiveMessage', data);
  });

  socket.on('goToNextPhase', function() {
    socket.broadcast.emit('nextPhase');
  });

  socket.on('isStarted?', function() {
    socket.emit('isStartedResponse', started[0]);
  });

  socket.on('cardUpdate', function(id) {
    io.emit('updatePlayerCards', id);
  });

  socket.on('nameChange', function(obj) {
    players[obj[0]].displayName = obj[1];
    socket.broadcast.emit('changeName', obj);
  });

  socket.on('setCurrentPlayer', function(id) {
    socket.broadcast.emit('setCurrentPlayer', id);
  });

  socket.on('returnID', function(id) {
    socket.emit('setCurrentPhase', [id, 'DRAW UP']);
  });

  socket.on('startDrawPhase', function (playerID) {
    console.log('DRAW PHASE');
    io.emit('setCurrentPlayer', playerID);
    Object.keys(players).forEach(player => {
      if (players[player].playerId === String(playerID)) {
        players[player].currentTurn = true;
      } else {
        players[player].currentTurn = false;
      }
    });
    playerCardsState.addPlayerCard(playerID, maxHandSize[Object.keys(players).length] - players[playerID].playerCards.length);
    io.emit('getIDs');
    setTimeout(function() {
      io.emit('updatePlayerCards', playerID);
    }, 500);
    setTimeout(function() {
      io.emit('nextPhase');
      socket.emit('startClientDiscardPhase', playerID);
    }, 2000);
  });

  socket.on('startDiscardPhase', function(id) {
    console.log('DISCARD PHASE');

  });

  socket.on('startTradePhase', function(id) {
    console.log('TRADE PHASE');

  });

  socket.on("disconnect", () => {
    if (players[socket.id].currentTurn) {
      let playerIndex = Object.keys(players).indexOf(socket.id);
      console.log("Client disconnected at id: " + socket.id);
      delete players[socket.id];
      io.emit('disconnect', socket.id);
      io.emit('disconnectUpdate', players);
      let nextPlayer = Object.keys(players)[playerIndex % Object.keys(players).length];
      socket.broadcast.emit('startDisconnectDrawPhase', nextPlayer);
    } else {
      console.log("Client disconnected at id: " + socket.id);
      delete players[socket.id];
      io.emit('disconnect', socket.id);
      io.emit('disconnectUpdate', players);
    }
  });
});

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port, () => {console.log(`Listening on port ${port}`)});

// GAME LOGIC
let maxHandSize = {1: 6, 2: 5, 3: 5, 4: 5, 5: 4, 6: 4};
let phaseSkippable = {0: false, 1: true, 2: true, 3: true, 4: false, 5: false};
let winCondition = false;
let loseCondition = false;

const initializePhase = async () => {
  started[0] = false;
  MonstersState.clearBoard();
  MonstersState.initializeBoard();
  playerDeckState.removePlayerCardIndices();
  playerCardsState.clearPlayerCards();
  playerDeckState.initializePlayerDeck();
};

const tradeCardsPhase = async (playerID) => {

};

const playCardsPhase = async (playerID) => {

};

const missing = [false];

const moveMonstersPhase = async (playerID) => {

};

const spawnMonstersPhase = async (playerID) => {

};

// GAME LOOP
let player;
const main = () => {
    // START GAME
    console.log('MAIN HAS STARTED');
    player = Object.keys(players)[0];
    return player;
};

initializePhase();
