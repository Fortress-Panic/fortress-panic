#!/usr/bin/env node
// jshint esversion:8
/**
 * Module dependencies.
 */
var app = require('../app');
var http = require('http');
const configDB = require('../config/properties');
const socketIO = require('socket.io');
const fetch = require('node-fetch');
const playerCardsState = require('../player-cards/player-cards.state');
const playerCardsModel = require('../player-cards/player-cards.dao');
const playerDeckState = require('../player-deck/player-deck.state');
const playerDeckModel = require('../player-deck/player-deck.dao');
const monsterDeckState = require('../monster-deck/monster-deck.states');
const monsterDeckModel = require('../monster-deck/monster-deck.dao');
const MonstersState = require('../monsters/monsters.states');
const monstersModel = require('../monsters/monsters.dao');
const defensesState = require('../defenses/defenses.states');
const defensesModel = require('../defenses/defenses.dao');

/**
 * Get port from environment and store in Express.
 */

var port = process.env.PORT || configDB.PORT;
// app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);
const io = socketIO(server);

let players = {};
let started = [false];

io.on("connection", (socket) => {
  console.log("New client connected at id: " + socket.id);
  players[socket.id] = {
    playerId: socket.id,
    displayName: 'Player ' + socket.id.slice(0,4),
    playerCards: [],
    points: 0,
    logged: false,
    currentTurn: false
  };
  // send the players object to the new player
  socket.emit('currentPlayers', players);

  socket.emit('getDefenses');

  socket.emit('getMonsters');

  socket.emit('hasGameStarted', started[0]);

  socket.broadcast.emit('getCurrentPlayer', socket.id);

  socket.broadcast.emit('getCurrentPhase', socket.id);

  socket.on('returnCurrentPhase', function(obj) {
      io.emit('setCurrentPhase', obj);
  });

  socket.on('returnCurrentPlayer', function(obj) {
    io.emit('updateCurrentPlayer', obj);
  });
  // update all other players of the new player
  socket.broadcast.emit('newPlayer', players[socket.id]);

  socket.on('firstStartButtonPress', function() {
    started[0] = true;
    socket.broadcast.emit('otherPlayerStartedGame', 'THE GAME HAS STARTED.');
    let currentPlayer = main();
    socket.emit('startClientDrawPhase', currentPlayer);
  });

  socket.on('playerLogin', function(id) {
    players[socket.id].logged = true; 
    io.emit('updateLoginName', id);
  });

  socket.on('logOutPlayer', function(id) {
    players[id].displayName = 'Player ' + id.slice(0,4);
    players[socket.id].logged = false;
    socket.broadcast.emit('logOutPlayer', id);
    socket.broadcast.emit('changeName', [id, 'Player ' + id.slice(0,4)]);
  });

  socket.on('sendMessage', function(data){
    io.emit('receiveMessage', data);
  });

  socket.on('goToNextPhase', function() {
    socket.broadcast.emit('nextPhase');
  });

  socket.on('isStarted?', function() {
    socket.emit('isStartedResponse', started[0]);
  });

  socket.on('cardUpdate', function(id) {
    io.emit('updatePlayerCards', id);
  });

  socket.on('nameChange', function(obj) {
    players[obj[0]].displayName = obj[1];
    socket.broadcast.emit('changeName', obj);
  });

  socket.on('setCurrentPlayer', function(id) {
    socket.broadcast.emit('setCurrentPlayer', id);
  });

  socket.on('returnID', function(id) {
    socket.emit('setCurrentPhase', [id, 'DRAW UP']);
  });

  socket.on('startDrawPhase', function (playerID) {
    console.log('DRAW PHASE');
    io.emit('setCurrentPlayer', playerID);
    Object.keys(players).forEach(player => {
      if (players[player].playerId === String(playerID)) {
        players[player].currentTurn = true;
      } else {
        players[player].currentTurn = false;
      }
    });
    playerCardsState.addPlayerCard(playerID, Math.max(maxHandSize[Object.keys(players).length] - players[playerID].playerCards.length), 0);
    io.emit('getIDs');
    setTimeout(function() {
      io.emit('updatePlayerCards', playerID);
    }, 500);
    setTimeout(function() {
      io.emit('nextPhase');
      socket.emit('startClientDiscardPhase', playerID);
    }, 2000);
  });

  socket.on('startDiscardPhase', function(id) {
    console.log('DISCARD PHASE');
    io.emit('allowDiscard');
  });

  socket.on('discardAndDraw', function(obj) {
    playerCardsState.discardCard(obj[1]);
    playerCardsState.addPlayerCard(obj[0], 1);
    setTimeout(function() {
      io.emit('updatePlayerCards', obj[0]);
    }, 500);
  });

  socket.on('startTradePhase', function(id) {
    console.log('TRADE PHASE');
    io.emit('allowTrade');

  });

  socket.on('tradeTargetSet', function(obj) {
    io.emit('initiateTrade', obj);
  });

  socket.on('tradeResult', function(obj) {
    io.emit('displayTradeResult', obj);
  });

  socket.on('tradeAccepted', function(obj) {
    playerCardsState.tradeCards(obj[0].position, obj[1].position, obj[0]._id, obj[1]._id);
    setTimeout(function() {
      io.emit('updatePlayerCards', obj[0].position);
      io.emit('updatePlayerCards', obj[1].position);
    }, 500);
  });

  socket.on('startPlayPhase', function(id) {
    console.log('PLAY PHASE');

  });

  socket.on('playCard', function(obj) {
    if (obj.key < 29) {
      io.emit('playHitCard', [obj.position, monsterRegions[obj.key]]);
    } else if (obj.key === 29) {
      io.emit('playSlayerCard', [obj.position, monsterRegions[obj.key]]);
    } else if (obj.key > 29 && obj.key < 37) {
      io.emit('playHitCard', [obj.position, monsterRegions[obj.key]]);
    } else if (obj.key > 36 && obj.key < 39) {
      io.emit('playDriveItBackCard', obj.position);
    } else if (obj.key > 38 && obj.key < 41) {
      io.emit('playNiceShotCard', obj.position);
    } else if (obj.key > 40 && obj.key < 43) {
      io.emit('playMissingCard', obj.position);
    } else if (obj.key > 42 && obj.key < 47) {
        if (obj.name === 'BRICK') {
          io.emit('playBrickCard', obj.position);
        } else if (obj.name === 'MORTAR') {
          io.emit('playMortarCard', obj.position);
        }
    } else if (obj.key > 46 && obj.key < 49) {
      io.emit('playJokerCard', obj.position);
    }
  });

  socket.on('hitMonster', function(id) {
    MonstersState.hitMonster(id);
    setTimeout(function() {
      io.emit('getMonsters');
    }, 100);
    socket.emit('getSelectedCard');
  });

  socket.on('killMonster', function(id) {
    MonstersState.killMonster(id);
    setTimeout(function() {
      io.emit('getMonsters');
    }, 100);
    socket.emit('getSelectedCard');
  });

  socket.on('driveItBack', function(obj) {
    monstersModel.findByIdAndUpdate(obj[0], {location: 'forest ' + obj[1].slice(obj[1].length - 1)}).exec();
    setTimeout(function() {
      io.emit('getMonsters');
    }, 400);
    socket.emit('getSelectedCard');
  });

  socket.on('niceShot', function() {
    socket.emit('getSelectedCard');
  });

  socket.on('missing', function() {
    socket.emit('getSelectedCard');
  });

  socket.on('joker', function(obj) {
    playerCardsState.addPlayerCard(obj[0], Math.min(Math.max(maxHandSize[Object.keys(players).length] - obj[1], 0), 2));
    setTimeout(function() {
      io.emit('updatePlayerCards', obj[0]);
    }, 500);
  });

  socket.on('rebuild', function(loc) {
    defensesState.rebuildWall(loc.slice(loc.length-1));
    setTimeout(function() {
      io.emit('getDefenses');
    }, 400);
  });

  socket.on('returnSelectedCard', function(obj) {
    playerCardsState.discardCard(obj[1]._id);
    setTimeout(function() {
      io.emit('updatePlayerCards', obj[0]);
    }, 500);
  });

  socket.on('startMoveMonstersPhase', function(id) {
    console.log('MOVE MONSTERS PHASE');
    io.emit('endPlayPhase', id);
  });

  socket.on('moveMonsters', function() {
    MonstersState.moveMonsters(null);
    setTimeout(function() {
      io.emit('getMonsters');
    }, 100);
  });

  socket.on("disconnect", () => {
    if (players[socket.id].currentTurn) {
      let playerIndex = Object.keys(players).indexOf(socket.id);
      console.log("Client disconnected at id: " + socket.id);
      delete players[socket.id];
      io.emit('disconnect', socket.id);
      io.emit('disconnectUpdate', players);
      let nextPlayer = Object.keys(players)[playerIndex % Object.keys(players).length];
      socket.broadcast.emit('startDisconnectDrawPhase', nextPlayer);
    } else {
      console.log("Client disconnected at id: " + socket.id);
      delete players[socket.id];
      io.emit('disconnect', socket.id);
      io.emit('disconnectUpdate', players);
    }
  });
});

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port, () => {console.log(`Listening on port ${port}`)});

// GAME LOGIC
let maxHandSize = {1: 6, 2: 5, 3: 5, 4: 5, 5: 4, 6: 4};
let phaseSkippable = {0: false, 1: true, 2: true, 3: true, 4: false, 5: false};
let winCondition = false;
let loseCondition = false;
let monsterRegions = {
  0: ['archer 1', 'archer 2'],
  1: ['archer 1', 'archer 2'],
  2: ['archer 1', 'archer 2'],
  3: ['knight 1', 'knight 2'],
  4: ['knight 1', 'knight 2'],
  5: ['knight 1', 'knight 2'],
  6: ['swordsman 1', 'swordsman 2'],
  7: ['swordsman 1', 'swordsman 2'],
  8: ['swordsman 1', 'swordsman 2'],
  9: ['archer 3', 'archer 4'],
  10: ['archer 3', 'archer 4'],
  11: ['archer 3', 'archer 4'],
  12: ['knight 3', 'knight 4'],
  13: ['knight 3', 'knight 4'],
  14: ['knight 3', 'knight 4'],
  15: ['swordsman 3', 'swordsman 4'],
  16: ['swordsman 3', 'swordsman 4'],
  17: ['swordsman 3', 'swordsman 4'],
  18: ['archer 5', 'archer 6'],
  19: ['archer 5', 'archer 6'],
  20: ['archer 5', 'archer 6'],
  21: ['knight 5', 'knight 6'],
  22: ['knight 5', 'knight 6'],
  23: ['knight 5', 'knight 6'],
  24: ['swordsman 5', 'swordsman 6'],
  25: ['swordsman 5', 'swordsman 6'],
  26: ['swordsman 5', 'swordsman 6'],
  27: ['castle 1', 'castle 2', 'castle 3', 'castle 4', 'castle 5', 'castle 6'],
  28: ['castle 1', 'castle 2', 'castle 3', 'castle 4', 'castle 5', 'castle 6'],
  29: ['castle 1', 'castle 2', 'castle 3', 'castle 4', 'castle 5', 'castle 6', 
      'archer 1', 'archer 2', 'archer 3', 'archer 4', 'archer 5', 'archer 6', 
      'knight 1', 'knight 2', 'knight 3', 'knight 4', 'knight 5', 'knight 6',
      'swordsman 1', 'swordsman 2', 'swordsman 3', 'swordsman 4', 'swordsman 5', 'swordsman 6',
      'forest 1', 'forest 2', 'forest 3', 'forest 4', 'forest 5', 'forest 6'],
  30: ['archer 1', 'archer 2', 'archer 3', 'archer 4', 'archer 5', 'archer 6'],
  31: ['knight 1', 'knight 2', 'knight 3', 'knight 4', 'knight 5', 'knight 6'],
  32: ['swordsman 1', 'swordsman 2', 'swordsman 3', 'swordsman 4', 'swordsman 5', 'swordsman 6'],
  33: ['castle 1', 'castle 2', 'castle 3', 'castle 4', 'castle 5', 'castle 6', 
      'archer 1', 'archer 2', 'archer 3', 'archer 4', 'archer 5', 'archer 6', 
      'knight 1', 'knight 2', 'knight 3', 'knight 4', 'knight 5', 'knight 6',
      'swordsman 1', 'swordsman 2', 'swordsman 3', 'swordsman 4', 'swordsman 5', 'swordsman 6',
      'forest 1', 'forest 2', 'forest 3', 'forest 4', 'forest 5', 'forest 6'],
  34: ['castle 1', 'castle 2', 'archer 1', 'archer 2', 'knight 1', 'knight 2', 'swordsman 1', 'swordsman 2', 'forest 1', 'forest 2'],
  35: ['castle 5', 'castle 6', 'archer 5', 'archer 6', 'knight 5', 'knight 6', 'swordsman 5', 'swordsman 6', 'forest 5', 'forest 6'],
  36: ['castle 3', 'castle 4', 'archer 3', 'archer 4', 'knight 3', 'knight 4', 'swordsman 3', 'swordsman 4', 'forest 3', 'forest 4'],
  37: ['castle 1', 'castle 2', 'castle 3', 'castle 4', 'castle 5', 'castle 6', 
      'archer 1', 'archer 2', 'archer 3', 'archer 4', 'archer 5', 'archer 6', 
      'knight 1', 'knight 2', 'knight 3', 'knight 4', 'knight 5', 'knight 6',
      'swordsman 1', 'swordsman 2', 'swordsman 3', 'swordsman 4', 'swordsman 5', 'swordsman 6',
      'forest 1', 'forest 2', 'forest 3', 'forest 4', 'forest 5', 'forest 6'],
  38: ['castle 1', 'castle 2', 'castle 3', 'castle 4', 'castle 5', 'castle 6', 
      'archer 1', 'archer 2', 'archer 3', 'archer 4', 'archer 5', 'archer 6', 
      'knight 1', 'knight 2', 'knight 3', 'knight 4', 'knight 5', 'knight 6',
      'swordsman 1', 'swordsman 2', 'swordsman 3', 'swordsman 4', 'swordsman 5', 'swordsman 6',
      'forest 1', 'forest 2', 'forest 3', 'forest 4', 'forest 5', 'forest 6']
};

const initializePhase = async () => {
  started[0] = false;
  MonstersState.clearBoard();
  MonstersState.initializeBoard();
  playerDeckState.removePlayerCardIndices();
  playerCardsState.clearPlayerCards();
  playerDeckState.initializePlayerDeck();
};

const tradeCardsPhase = async (playerID) => {

};

const playCardsPhase = async (playerID) => {

};

const missing = [false];

const moveMonstersPhase = async (playerID) => {

};

const spawnMonstersPhase = async (playerID) => {

};

// GAME LOOP
let player;
const main = () => {
    // START GAME
    console.log('MAIN HAS STARTED');
    player = Object.keys(players)[0];
    return player;
};

initializePhase();
